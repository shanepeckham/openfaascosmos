package function

import (
	"crypto/tls"
	"encoding/json"
	"fmt"
	"log"
	"net"
	"net/url"
	"os"
	"strings"
	"time"

	mgo "gopkg.in/mgo.v2"
)

var mongoURL = os.Getenv("NODE_ENV")

var (
	database string
	password string
	status   string
)

var session *mgo.Session
var asession *mgo.Session
var collection *mgo.Collection
var serr error

type Plan struct {
	ID           string `required:"false" description:"CosmoDB ID - will be autogenerated"`
	Name         string `required:"false" description:"email"`
	FriendlyName string `required:"false" description:"pwd"`
	PortionSize  string `required:"false" description:"firstname"`
	MealsPerWeek string `required:"false" description:"lastname"`
	Price        int    `required:"false" description:"address"`
	Description  string `required:"false" description:"city"`
	_V           int    `required:"false" description:"__v"`
}

// Handle a serverless request
func Handle(req []byte) string {

	url, err := url.Parse(mongoURL)
	if err != nil {
		log.Fatal("Problem parsing url: ", err)
		return "Problem parsing url"
	}

	st := fmt.Sprintf("%s", url.User)
	co := strings.Index(st, ":")

	database = st[:co]
	password = st[co+1:]

	// DialInfo holds options for establishing a session with a MongoDB cluster.
	dialInfo := &mgo.DialInfo{
		Addrs:    []string{fmt.Sprintf("%s.documents.azure.com:10255", database)}, // Get HOST + PORT
		Timeout:  60 * time.Second,
		Database: database, // It can be anything
		Username: database, // Username
		Password: password, // PASSWORD
		DialServer: func(addr *mgo.ServerAddr) (net.Conn, error) {
			return tls.Dial("tcp", addr.String(), &tls.Config{})
		},
	}

	session, serr = mgo.DialWithInfo(dialInfo)
	if serr != nil {
		log.Fatal("Can't connect to CosmosDB, go error", serr)
		status = "Can't connect to CosmosDB, go error %v\n"
		return "Can't connect to CosmosDB"
	}
	defer session.Close()

	session.SetSafe(&mgo.Safe{})

	// get collection
	collection = session.DB("best-for-you-organics").C("plans")

	// Get Document from collection
	//	result := User{}
	result := make([]Plan, 0, 10)

	//err = collection.Find(bson.M{"email": "john.smith@bfyo.com"}).One(&result)
	err = collection.Find(nil).All(&result)
	mResult, err := json.Marshal(result)

	if err != nil {
		log.Fatal("Error finding record: ", err)
		return "Error finding record"
	}
	res := fmt.Sprintf("%s", mResult)
	return res
}
